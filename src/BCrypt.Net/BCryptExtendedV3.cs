#if NETCOREAPP
using System.Globalization;
using System.Security.Cryptography;

namespace BCryptNet;
/// <summary>
/// BCrypt Enhanced
/// Created to be compatible with other programming-language implementations of pre-hashed keys
/// i.e. passlib in python / php bcrypt and sha
/// </summary>
///  <para>
///         To hash a password using SHA384 pre-hashing for increased entropy see <see cref="BCryptExtendedV3.HashPassword(string, string, int, HashType)"/>
///  </para>
///  <c>
///     string pw_hash = BCryptExtendedV3.HashPassword(hmac_key, plain_password);
///     // (To validate an enhanced hash you can pass true as the last parameter of Verify or use  <see cref="BCryptExtendedV3.Verify(string, string, string, HashType)"/>)
///  </c>
[System.Diagnostics.CodeAnalysis.SuppressMessage("ApiDesign", "RS0026:Do not add multiple public overloads with optional parameters", Justification = "Overloads are for different purposes")]
public sealed class BCryptExtendedV3 : BCryptCore
{
    private const HashType DefaultEnhancedHashType = HashType.SHA384;

    /// <summary>
    ///  Pre-hash a password with HMAC-SHA3-384 then using the OpenBSD BCrypt scheme and a salt generated by <see cref="BCryptCore.GenerateSalt(int,char)"/>.
    /// <seealso href="https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha3_256?view=net-9.0"/>
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey">The password to hash.</param>
    /// <param name="workFactor"></param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA384)</param>
    /// <returns>The hashed password.</returns>
    /// <exception cref="SaltParseException">Thrown when the salt could not be parsed.</exception>
    public static string HashPassword(string hmacKey, string inputKey, int workFactor = DefaultRounds, HashType hashType = DefaultEnhancedHashType)
    {
        return CreatePasswordHash(inputKey, GenerateSalt(workFactor), hashType, (key, type, version) => EnhancedHash(hmacKey, key, type, version));
    }

    /// <summary>
    ///  Pre-hash a password with HMAC-SHA3-384 then using the OpenBSD BCrypt scheme and a salt generated by <see cref="BCryptCore.GenerateSalt(int,char)"/>.
    /// <seealso href="https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha3_256?view=net-9.0"/>
    /// </summary>
    /// <remarks>
    ///  <para>You should generally leave generating salts to the library.</para>
    /// </remarks>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey">The password to hash.</param>
    /// <param name="salt"></param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA384)</param>
    /// <returns>The hashed password.</returns>
    /// <exception cref="SaltParseException">Thrown when the salt could not be parsed.</exception>
    public static string HashPassword(string hmacKey, string inputKey, string salt, HashType hashType = DefaultEnhancedHashType) =>
        CreatePasswordHash(inputKey, salt, hashType, (key, type, version) => EnhancedHash(hmacKey,key, type, version));

    /// <summary>
    ///  Pre-hash a password with HMAC-SHA3-384 then using the OpenBSD BCrypt scheme and a salt generated by <see cref="BCryptCore.GenerateSalt(int,char)"/>.
    /// <seealso href="https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha3_256?view=net-9.0"/>
    /// </summary>
    /// <remarks>
    ///  <para>You should generally leave generating salts to the library.</para>
    /// </remarks>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey">The password to hash.</param>
    /// <param name="salt"></param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA384)</param>
    /// <returns>The hashed password.</returns>
    /// <exception cref="SaltParseException">Thrown when the salt could not be parsed.</exception>
    public static string HashPassword(string hmacKey, ReadOnlySpan<char> inputKey, ReadOnlySpan<char> salt, HashType hashType = DefaultEnhancedHashType) =>
        CreatePasswordHash(inputKey, salt, hashType, (key, type, version) => EnhancedHash(hmacKey,key, type, version));

    /// <summary>
    /// Hashes key, base64 encodes before returning byte array
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey"></param>
    /// <param name="bcryptMinorRevision">(Default: 'a')</param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA3 HMAC 384 - https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha3_256)</param>
    /// <returns></returns>
    private static Span<byte> EnhancedHash(ReadOnlySpan<char> hmacKey, ReadOnlySpan<char> inputKey, HashType hashType, char bcryptMinorRevision = 'a')
    {
        switch (hashType)
        {
            case HashType.SHA256:
                using (var sha = new HMACSHA3_256(BCryptCore.SafeUTF8.GetBytes(hmacKey.ToString())))
                    return BCryptCore.SafeUTF8.GetBytes(Convert.ToBase64String(sha.ComputeHash(BCryptCore.SafeUTF8.GetBytes(inputKey.ToString()))) +
                                                        (bcryptMinorRevision >= 'a' ? BCryptCore.Nul : BCryptCore.EmptyString)).AsSpan();
            case HashType.SHA384:
                using (var sha = new HMACSHA3_384(BCryptCore.SafeUTF8.GetBytes(hmacKey.ToString())))
                    return BCryptCore.SafeUTF8.GetBytes(Convert.ToBase64String(sha.ComputeHash(BCryptCore.SafeUTF8.GetBytes(inputKey.ToString()))) +
                                                        (bcryptMinorRevision >= 'a' ? BCryptCore.Nul : BCryptCore.EmptyString));
            case HashType.SHA512:
                using (var sha = new HMACSHA3_512(BCryptCore.SafeUTF8.GetBytes(hmacKey.ToString())))
                    return BCryptCore.SafeUTF8.GetBytes(Convert.ToBase64String(sha.ComputeHash(BCryptCore.SafeUTF8.GetBytes(inputKey.ToString()))) +
                                                        (bcryptMinorRevision >= 'a' ? BCryptCore.Nul : BCryptCore.EmptyString));
            case HashType.None:
            default:
                throw new ArgumentOutOfRangeException(nameof(hashType), hashType, null);
        }
    }

    /// <summary>
    /// Compares the users stored hash with their password
    /// in a time-safe manner
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey"></param>
    /// <param name="hash"></param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA384)</param>
    /// <returns></returns>
    public static bool Verify(string hmacKey, string inputKey, string hash, HashType hashType = DefaultEnhancedHashType)
    {
        return SecureEquals(SafeUTF8.GetBytes(hash),
            SafeUTF8.GetBytes(CreatePasswordHash(inputKey, hash, hashType,
                (key, type, version) => EnhancedHash(hmacKey, key, type, version))));
    }

    /// <summary>
    /// Validate and Upgrade Hash
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="currentKey"></param>
    /// <param name="currentHash"></param>
    /// <param name="newKey"></param>
    /// <param name="hashType"></param>
    /// <param name="workFactor"></param>
    /// <param name="forceWorkFactor"></param>
    /// <returns></returns>
    public static string ValidateAndUpgradeHash(
        string hmacKey,
        string currentKey,
        string currentHash,
        string newKey,
        HashType hashType = DefaultEnhancedHashType,
        int workFactor = DefaultRounds,
        bool forceWorkFactor = false)
    {
        return ValidateAndUpgradeHash(hmacKey, currentKey, currentHash, DefaultEnhancedHashType, newKey, hashType, workFactor, forceWorkFactor);
    }

    /// <summary>
    /// Validate and Upgrade Hash
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="currentKey"></param>
    /// <param name="currentHash"></param>
    /// <param name="currentKeyHashType"></param>
    /// <param name="newKey"></param>
    /// <param name="hashType"></param>
    /// <param name="workFactor"></param>
    /// <param name="forceWorkFactor"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentNullException"></exception>
    /// <exception cref="ArgumentException"></exception>
    /// <exception cref="BcryptAuthenticationException"></exception>
    /// <exception cref="SaltParseException"></exception>
    public static string ValidateAndUpgradeHash(
        string hmacKey,
        string currentKey,
        string currentHash,
        HashType currentKeyHashType,
        string newKey,
        HashType hashType = DefaultEnhancedHashType,
        int workFactor = DefaultRounds,
        bool forceWorkFactor = false)
    {
        ArgumentNullException.ThrowIfNull(hmacKey);
        ArgumentNullException.ThrowIfNull(currentKey);

        if (string.IsNullOrEmpty(currentHash) || currentHash.Length != 60)
            throw new ArgumentException("Invalid Hash", nameof(currentHash));

        // Throw if validation fails (password isn't valid for hash)
        if (!Verify(hmacKey, currentKey, currentHash, currentKeyHashType))
            throw new BcryptAuthenticationException("Current credentials could not be authenticated");

        // Throw if invalid BCrypt Version
        if (currentHash[0] != '$' || currentHash[1] != '2')
            throw new SaltParseException("Invalid bcrypt version");

        // Throw if log rounds are out of range on hash, deals with custom salts
        if (workFactor < 1 || workFactor > 31)
            throw new SaltParseException("Work factor out of range");

        // Determine the starting offset and validate the salt
        int startingOffset = 3;

        if (currentHash[2] != '$')
        {
            char minor = currentHash[2];
            if (minor != 'a' && minor != 'b' && minor != 'x' && minor != 'y' || currentHash[3] != '$')
            {
                throw new SaltParseException("Invalid bcrypt revision");
            }

            startingOffset = 4;
        }

        // Extract number of rounds
        if (currentHash[startingOffset + 2] > '$')
        {
            throw new SaltParseException("Missing work factor");
        }

        // Extract details from salt
        int currentWorkFactor = Convert.ToInt16(currentHash.Substring(startingOffset, 2), CultureInfo.InvariantCulture);

        // Never downgrade work-factor (unless forced)
        if (!forceWorkFactor && currentWorkFactor > workFactor)
        {
            workFactor = currentWorkFactor;
        }

        return CreatePasswordHash(newKey, GenerateSalt(workFactor), hashType,
            (key, type, version) => EnhancedHash(hmacKey, key, type, version));
    }
}
#endif
