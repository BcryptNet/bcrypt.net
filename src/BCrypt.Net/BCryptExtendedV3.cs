#if NETCOREAPP
using System.Diagnostics;
using System.Globalization;
using System.Security.Cryptography;

namespace BCryptNet;
/// <summary>
/// BCrypt Enhanced
/// Created to be compatible with other programming-language implementations of pre-hashed keys
/// i.e. passlib in python / php bcrypt and sha
/// </summary>
///  <para>
///         To hash a password using SHA384 pre-hashing for increased entropy see <see cref="BCryptExtendedV3.HashPassword(string, string, int, HashType)"/>
///  </para>
///  <c>
///     string pw_hash = BCryptExtendedV3.HashPassword(hmac_key, plain_password);
///     // (To validate an enhanced hash you can pass true as the last parameter of Verify or use  <see cref="BCryptExtendedV3.Verify(string, string, string, HashType)"/>)
///  </c>
[System.Diagnostics.CodeAnalysis.SuppressMessage("ApiDesign", "RS0026:Do not add multiple public overloads with optional parameters", Justification = "Overloads are for different purposes")]
public sealed class BCryptExtendedV3 : BCryptCore
{
    private const HashType DefaultEnhancedHashType = HashType.SHA384;

    /// <summary>
    ///  Pre-hash a password with HMAC-SHA3-384 then using the OpenBSD BCrypt scheme and a salt generated by <see cref="BCryptCore.GenerateSalt(int,char)"/>.
    /// <seealso href="https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha3_256?view=net-9.0"/>
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey">The password to hash.</param>
    /// <param name="workFactor"></param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA384)</param>
    /// <returns>The hashed password.</returns>
    /// <exception cref="SaltParseException">Thrown when the salt could not be parsed.</exception>
    public static string HashPassword(string hmacKey, string inputKey, int workFactor = DefaultRounds, HashType hashType = DefaultEnhancedHashType)
    {
        return CreatePasswordHash(inputKey, GenerateSalt(workFactor), hashType, (key, type, version) => EnhancedHash(hmacKey, key, type, version));
    }

    /// <summary>
    ///  Pre-hash a password with HMAC-SHA3-384 then using the OpenBSD BCrypt scheme and a salt generated by <see cref="BCryptCore.GenerateSalt(int,char)"/>.
    /// <seealso href="https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha3_256?view=net-9.0"/>
    /// </summary>
    /// <remarks>
    ///  <para>You should generally leave generating salts to the library.</para>
    /// </remarks>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey">The password to hash.</param>
    /// <param name="salt"></param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA384)</param>
    /// <returns>The hashed password.</returns>
    /// <exception cref="SaltParseException">Thrown when the salt could not be parsed.</exception>
    public static string HashPassword(string hmacKey, string inputKey, string salt, HashType hashType = DefaultEnhancedHashType) =>
        CreatePasswordHash(inputKey, salt, hashType, (key, type, version) => EnhancedHash(hmacKey,key, type, version));

    /// <summary>
    ///  Pre-hash a password with HMAC-SHA3-384 then using the OpenBSD BCrypt scheme and a salt generated by <see cref="BCryptCore.GenerateSalt(int,char)"/>.
    /// <seealso href="https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha3_256?view=net-9.0"/>
    /// </summary>
    /// <remarks>
    ///  <para>You should generally leave generating salts to the library.</para>
    /// </remarks>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey">The password to hash.</param>
    /// <param name="salt"></param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA384)</param>
    /// <returns>The hashed password.</returns>
    /// <exception cref="SaltParseException">Thrown when the salt could not be parsed.</exception>
    public static string HashPassword(string hmacKey, ReadOnlySpan<char> inputKey, ReadOnlySpan<char> salt, HashType hashType = DefaultEnhancedHashType)
    {
        return CreatePasswordHash(inputKey, salt, hashType, (key, type, version) => EnhancedHash(hmacKey, key, type, version));
    }

    /// <summary>
    /// HMAC-SHA3 hashes input key before bcrypt hashing
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey"></param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA3 HMAC 384 - https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha3_256)</param>
    /// <param name="bcryptMinorRevision">(Default: 'a')</param>
    /// <returns></returns>
    private static byte[] EnhancedHash(ReadOnlySpan<char> hmacKey, ReadOnlySpan<char> inputKey, HashType hashType, char bcryptMinorRevision = 'a')
    {
        ushort hashLen = hashType switch
        {
            HashType.SHA256 => 32,
            HashType.SHA384 => 48,
            HashType.SHA512 => 64,
            _ => throw new ArgumentOutOfRangeException(nameof(hashType))
        };

        Span<byte> keyBytes = stackalloc byte[SafeUTF8.GetMaxByteCount(hmacKey.Length)];
        Span<byte> dataBytes = stackalloc byte[SafeUTF8.GetMaxByteCount(inputKey.Length)];
        Span<byte> hash = stackalloc byte[hashLen];

        // UTF8 encode key and data
        int keyByteLen = SafeUTF8.GetBytes(hmacKey, keyBytes);
        int dataByteLen = SafeUTF8.GetBytes(inputKey, dataBytes);

        // Perform HMAC
        bool success = hashType switch
        {
            HashType.SHA256 => HMACSHA3_256.TryHashData(keyBytes[..keyByteLen], dataBytes[..dataByteLen], hash, out int len) && len == 32,
            HashType.SHA384 => HMACSHA3_384.TryHashData(keyBytes[..keyByteLen], dataBytes[..dataByteLen], hash, out int len) && len == 48,
            HashType.SHA512 => HMACSHA3_512.TryHashData(keyBytes[..keyByteLen], dataBytes[..dataByteLen], hash, out int len) && len == 64,
            _ => throw new ArgumentOutOfRangeException(nameof(hashType))
        };

        if (!success)
            throw new BcryptAuthenticationException($"HMAC-{hashType} failed");

        // Base64 encode
        Span<char> base64Chars = stackalloc char[(hashLen + 2) / 3 * 4];
        if (!Convert.TryToBase64Chars(hash, base64Chars, out int base64Len))
            throw new BcryptAuthenticationException("Base64 encoding failed in EnhancedHash");

        // Append `Nul` only **after** base64 encoding
        Span<char> finalBase64 = stackalloc char[base64Len + (bcryptMinorRevision >= 'a' ? 1 : 0)];
        base64Chars[..base64Len].CopyTo(finalBase64);
        if (bcryptMinorRevision >= 'a') finalBase64[base64Len] = '\0';

        // UTF8 encode final base64 result
        Span<byte> utf8Buffer = stackalloc byte[SafeUTF8.GetMaxByteCount(finalBase64.Length)];
        int utf8Len = SafeUTF8.GetBytes(finalBase64, utf8Buffer);

        return utf8Buffer[..utf8Len].ToArray();
    }

    private static Span<byte> EnhancedHashOld(ReadOnlySpan<char> hmacKey, ReadOnlySpan<char> inputKey, HashType hashType, char bcryptMinorRevision = 'a')
    {
        switch (hashType)
        {
            case HashType.SHA256:
                using (var sha = new HMACSHA3_256(BCryptCore.SafeUTF8.GetBytes(hmacKey.ToString())))
                    return BCryptCore.SafeUTF8.GetBytes(Convert.ToBase64String(sha.ComputeHash(BCryptCore.SafeUTF8.GetBytes(inputKey.ToString()))) +
                                                        (bcryptMinorRevision >= 'a' ? BCryptCore.Nul : BCryptCore.EmptyString)).AsSpan();
            case HashType.SHA384:
                using (var sha = new HMACSHA3_384(BCryptCore.SafeUTF8.GetBytes(hmacKey.ToString())))
                    return BCryptCore.SafeUTF8.GetBytes(Convert.ToBase64String(sha.ComputeHash(BCryptCore.SafeUTF8.GetBytes(inputKey.ToString()))) +
                                                        (bcryptMinorRevision >= 'a' ? BCryptCore.Nul : BCryptCore.EmptyString));
            case HashType.SHA512:
                using (var sha = new HMACSHA3_512(BCryptCore.SafeUTF8.GetBytes(hmacKey.ToString())))
                    return BCryptCore.SafeUTF8.GetBytes(Convert.ToBase64String(sha.ComputeHash(BCryptCore.SafeUTF8.GetBytes(inputKey.ToString()))) +
                                                        (bcryptMinorRevision >= 'a' ? BCryptCore.Nul : BCryptCore.EmptyString));
            case HashType.None:
            default:
                throw new ArgumentOutOfRangeException(nameof(hashType), hashType, null);
        }
    }

    /// <summary>
    /// Compares the users stored hash with their password
    /// in a time-safe manner
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="inputKey"></param>
    /// <param name="hash"></param>
    /// <param name="hashType"><seealso cref="HashType"/>HashType used (default SHA384)</param>
    /// <returns></returns>
    public static bool Verify(string hmacKey, string inputKey, string hash, HashType hashType = DefaultEnhancedHashType)
    {
        return SecureEquals(SafeUTF8.GetBytes(hash),
            SafeUTF8.GetBytes(CreatePasswordHash(inputKey, hash, hashType,
                (key, type, version) => EnhancedHash(hmacKey, key, type, version))));
    }

    /// <summary>
    /// Validate and Upgrade Hash
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="currentKey"></param>
    /// <param name="currentHash"></param>
    /// <param name="newKey"></param>
    /// <param name="hashType"></param>
    /// <param name="workFactor"></param>
    /// <param name="forceWorkFactor"></param>
    /// <returns></returns>
    public static string ValidateAndUpgradeHash(
        string hmacKey,
        string currentKey,
        string currentHash,
        string newKey,
        HashType hashType = DefaultEnhancedHashType,
        int workFactor = DefaultRounds,
        bool forceWorkFactor = false)
    {
        return ValidateAndUpgradeHash(hmacKey, currentKey, currentHash, DefaultEnhancedHashType, newKey, hashType, workFactor, forceWorkFactor);
    }

    /// <summary>
    /// Validate and Upgrade Hash
    /// </summary>
    /// <param name="hmacKey">Key used in HMAC hashing</param>
    /// <param name="currentKey"></param>
    /// <param name="currentHash"></param>
    /// <param name="currentKeyHashType"></param>
    /// <param name="newKey"></param>
    /// <param name="hashType"></param>
    /// <param name="workFactor"></param>
    /// <param name="forceWorkFactor"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentNullException"></exception>
    /// <exception cref="ArgumentException"></exception>
    /// <exception cref="BcryptAuthenticationException"></exception>
    /// <exception cref="SaltParseException"></exception>
    public static string ValidateAndUpgradeHash(
        string hmacKey,
        string currentKey,
        string currentHash,
        HashType currentKeyHashType,
        string newKey,
        HashType hashType = DefaultEnhancedHashType,
        int workFactor = DefaultRounds,
        bool forceWorkFactor = false)
    {
        ArgumentNullException.ThrowIfNull(hmacKey);
        ArgumentNullException.ThrowIfNull(currentKey);

        if (string.IsNullOrEmpty(currentHash) || currentHash.Length != 60)
            throw new ArgumentException("Invalid Hash", nameof(currentHash));

        // Throw if validation fails (password isn't valid for hash)
        if (!Verify(hmacKey, currentKey, currentHash, currentKeyHashType))
            throw new BcryptAuthenticationException("Current credentials could not be authenticated");

        // Throw if invalid BCrypt Version
        if (currentHash[0] != '$' || currentHash[1] != '2')
            throw new SaltParseException("Invalid bcrypt version");

        // Throw if log rounds are out of range on hash, deals with custom salts
        if (workFactor < 1 || workFactor > 31)
            throw new SaltParseException("Work factor out of range");

        // Determine the starting offset and validate the salt
        int startingOffset = 3;

        if (currentHash[2] != '$')
        {
            char minor = currentHash[2];
            if (minor != 'a' && minor != 'b' && minor != 'x' && minor != 'y' || currentHash[3] != '$')
            {
                throw new SaltParseException("Invalid bcrypt revision");
            }

            startingOffset = 4;
        }

        // Extract number of rounds
        if (currentHash[startingOffset + 2] > '$')
        {
            throw new SaltParseException("Missing work factor");
        }

        // Extract details from salt
        int currentWorkFactor = Convert.ToInt16(currentHash.Substring(startingOffset, 2), CultureInfo.InvariantCulture);

        // Never downgrade work-factor (unless forced)
        if (!forceWorkFactor && currentWorkFactor > workFactor)
        {
            workFactor = currentWorkFactor;
        }

        return CreatePasswordHash(newKey, GenerateSalt(workFactor), hashType,
            (key, type, version) => EnhancedHash(hmacKey, key, type, version));
    }
}
#endif
